{"/home/travis/build/npmtest/node-npmtest-model/test.js":"/* istanbul instrument in package npmtest_model */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-model/lib.npmtest_model.js":"/* istanbul instrument in package npmtest_model */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_model = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_model = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-model/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-model && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_model */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_model\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_model.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_model.rollup.js'] =\n            local.assetsDict['/assets.npmtest_model.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_model.__dirname + '/lib.npmtest_model.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/index.js":"/*\n * Geddy JavaScript Web development framework\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n/*\nExample model file, would be app/models/user.js:\n\nvar User = function () {\n  this.property('login', 'string', {required: true});\n  this.property('password', 'string', {required: true});\n  this.property('lastName', 'string');\n  this.property('firstName', 'string');\n\n  this.validatesPresent('login');\n  this.validatesFormat('login', /[a-z]+/, {message: 'Subdivisions!'});\n  this.validatesLength('login', {min: 3});\n  this.validatesConfirmed('password', 'confirmPassword');\n  this.validatesWithFunction('password',\n      function (s) { return s.length > 0; // Could be anything\n  });\n};\n\nUser.prototype.someMethod = function () {\n  // Do some stuff on a User instance\n};\n\nUser = model.register('User', User);\n*/\n\nvar util = require('util') // Native Node util module\n  , model = {}\n  , EventEmitter = require('events').EventEmitter\n  , utils = require('utilities')\n  , config = require('./base_config')\n  , adapters = require('./adapters')\n  , Query\n  , query // Lazy-load query; it depends on model/index\n  , association; // Lazy-load query; it depends on model/index\n\nvar _foreignKeyCreators = []\n  , _systemProperties = {\n      id: true\n    , type: true\n    , createdAt: true\n    , updatedAt: true\n    };\n\nutils.mixin(model, new (function () {\n\n  this.config = config;\n  this.ModelBase = function () {};\n  this.adapters = {};\n  this.descriptionRegistry = {};\n  this.defaultAdapter = null;\n\n  this.datatypes = null // Lazy-load query; it depends on model/index\n  this.validators = require('./validators');\n  this.formatters = require('./formatters');\n  this.Migration = require('./migration').Migration;\n  this.log = function () {};\n\n  util.inherits(this.ModelBase, EventEmitter);\n\n  var _createModelItemConstructor = function (def) {\n    // Base constructor function for all model items\n    var ModelItemConstructor = function (params) {\n      var self = this\n        , associations = model.descriptionRegistry[def.name].associations;\n\n      this.type = def.name;\n      // Items fetched from an API should have this flag set to true\n      this._saved = params._saved || false;\n\n      // If fetched and instantiated from an API-call, give the\n      // instance the appropriate ID -- newly created objects won't\n      // have one until saved\n      if (params.id) {\n        this.id = params.id;\n      }\n\n      this.isValid = function () {\n        return !this.errors;\n      };\n\n      /**\n        @name ModelBase#save\n        @public\n        @function\n        @description Saves an instance of a Geddy ModelBase\n        @param {Object} [opts]\n          @param {String} [opts.locale=null] Optional locale for\n          localizing error messages from validations\n        @param {Function} [callback] Callback function that receives\n        the result of the save action -- should be in the format of\n        function (err, result) {}\n       */\n      this.save = function () {\n        var args = Array.prototype.slice.call(arguments)\n          , m = model[this.type];\n        args.unshift(this);\n        this._commitAssociationChanges(function (err, data) {\n          var cb;\n          if (err) {\n            cb = args.pop();\n            return cb(err);\n          }\n          m.save.apply(m, args);\n        });\n      };\n\n      /**\n        @name ModelBase#updateProperties\n        @public\n        @function\n        @description Updates the attributes an instance of a Geddy\n        ModelBase, and validate the changes\n        @param {Object} params Object-literal with updated values for\n        the instance\n        the result of the save action -- should be in the format of\n        function (err, result) {}\n        @param {Object} [opts]\n          @param {String} [opts.locale=null] Optional locale for\n          localizing error messages from validations\n       */\n      this.updateProperties = function (params, opts) {\n        model.updateItem(this, params, opts || {});\n      };\n      // TODO: Deprecate?\n      this.updateAttributes = this.updateProperties;\n      /**\n        @name ModelBase#toJSON\n        @public\n        @function\n        @description Returns an object with just the data properties\n        defined by its model\n       */\n      this.toJSON = function (options) {\n        var self = this\n          , opts = options || {}\n          , whitelist = Object.keys(_systemProperties)\n          , obj = {}\n          , reg = model.descriptionRegistry[this.type]\n          , properties = reg.properties\n          , associations = reg.associations || {}\n          , assns = {\n              hasMany: 'plural'\n            , hasOne: 'singular'\n            , belongsTo: 'singular'\n            }\n          , assnList\n          , assnName;\n\n        whitelist = whitelist.concat(opts.whitelist || [])\n\n        // First, simple defined properties\n        for (var p in properties) {\n          obj[p] = this[p];\n        }\n\n        // Assocations\n        for (var k in assns) {\n          assnList = associations[k];\n          for (var p in assnList) {\n            assnName = utils.string.getInflection(p, 'property', assns[k]);\n            if (this[assnName]) {\n              obj[assnName] = this[assnName];\n            }\n          }\n        }\n\n        // Any non-defined, but whitelisted properties\n        whitelist.forEach(function (p) {\n          if (self[p]) {\n            obj[p] = self[p];\n          }\n        });\n\n        return obj;\n      };\n\n      this.toData = this.toJSON;\n      this.toObj = this.toJSON;\n\n      this.toString = function () {\n        var obj = {}\n          , reg = model.descriptionRegistry[this.type]\n          , properties = reg.properties\n          , formatter;\n\n        obj.id = this.id;\n        obj.type = this.type;\n\n        for (var p in properties) {\n          formatter = model.formatters[properties[p].datatype];\n          obj[p] = typeof formatter == 'function' ?\n              formatter(this[p]) : this[p];\n        }\n\n        return JSON.stringify(obj);\n      };\n\n\n      this._getAssociation = association._getAssociation;\n      this._createAssociation = association._createAssociation;\n      this._removeAssociation = association._removeAssociation;\n      this._commitAssociationChanges = association._commitAssociationChanges;\n\n      /**\n        @name ModelBase#clone\n        @private\n        @function\n        @description Creates a 'deep copy' of the model object\n      */\n      this.clone = function () {\n        var itemClone;\n\n        // clone the item\n        itemClone = model[this.type].create(utils.enhance({}, this.toJSON(), {id:this.id}));\n        itemClone.associations = utils.enhance({}, this.associations);\n        itemClone._saved = this._saved;\n\n        return itemClone;\n      };\n\n      // Intstance-methods for associations\n      // get..., set.../add..., remove...\n      ['hasMany', 'hasOne', 'belongsTo'].forEach(function (k) {\n        var assns\n          , createMethod = function (type, keyName, assnType) {\n              return function () {\n                var args = Array.prototype.slice.call(arguments);\n                args.unshift(assnType);\n                args.unshift(keyName);\n                self[type + 'Association'].apply(self, args);\n              };\n            };\n        if ((assns = associations[k])) {\n          for (var assnName in assns) {\n            (function (assnName) {\n              var methodName = k == 'hasMany' ?\n                      utils.inflection.pluralize(assnName) : assnName\n                , keyForCreate = k == 'hasMany' ? 'add' : 'set';\n\n              // get can be singular or plural, depending on hasMany/hasOne\n              // this.getBooks({}, {}, function () {}); =>\n              // this._getAssociation('Book', 'hasMany', {}, {}, function () {});\n              self['get' + methodName] = createMethod('_get', assnName, k);\n\n              // add/set is always singular, just use assnName for method\n              // this.addBook(book); =>\n              // this._createAssociation('Book', 'hasMany', book);\n              self[keyForCreate + assnName] = createMethod('_create', assnName, k);\n\n              // this.removeBook(book); =>\n              // this._removeAssociation('Book', 'hasMany', book);\n              self['remove' + assnName] = createMethod('_remove', assnName, k);\n            })(assnName);\n          }\n        }\n      });\n\n    };\n\n    return ModelItemConstructor;\n  };\n\n  var _createStaticMethodsMixin = function (name) {\n    var obj = {};\n\n    /**\n      @name ModelBase.create\n      @public\n      @static\n      @function\n      @description Creates an instance of a Geddy ModelBase, validating\n      the input parameters\n      @param {Object} params Object-literal with updated values for\n      the instance\n      the result of the save action -- should be in the format of\n      function (err, result) {}\n      @param {Object} [opts]\n        @param {String} [opts.locale=null] Optional locale for\n        localizing error messages from validations\n     */\n    obj.create = function () {\n      var args = Array.prototype.slice.call(arguments);\n      args.unshift(name);\n      return model.createItem.apply(model, args);\n    };\n\n    obj.getAdapter = function() {\n      return model.getAdapterForModel(name);\n    };\n\n    // Returns the first item found\n    obj.first = function () {\n      var args = Array.prototype.slice.call(arguments)\n        , callback = args.pop()\n        , query = args.shift() || {}\n        , opts = args.shift() || {}\n        , includeOpts;\n\n      if (typeof query == 'string' || typeof query == 'number') {\n        query = {id: query};\n      }\n\n      if (!opts.id) {\n        opts.limit = 1;\n        // Can't use simple LIMIT with eager-fetch of associations\n        // Do an additional query with LIMIT to fetch the first object,\n        // then the normal query by ID with associations\n        if (opts.includes) {\n          includeOpts = utils.mixin({}, opts);\n          delete includeOpts.includes;\n          return obj.all(query, includeOpts, function (err, data) {\n            if (err) {\n              return callback(err, null);\n            }\n            if (data && data.id) {\n              delete opts.limit;\n              // TODO: If queries eventually return EventEmitters,\n              // need to proxy the events upward to the wrapping query\n              obj.all({id: data.id}, opts, function (err, data) {\n                if (err) {\n                  return callback(err, null);\n                }\n                if (data && data.length) {\n                  callback(null, data[0]);\n                }\n                else {\n                  callback(null, null);\n                }\n              });\n            }\n            else {\n              callback(null, null);\n            }\n          });\n        }\n      }\n\n      return obj.all(query, opts, callback);\n    };\n\n    obj.count = function() {\n      var args = Array.prototype.slice.call(arguments)\n        , callback = args.pop() || function () {}\n        , query = args.shift() || {}\n        , opts = args.shift() || {};\n      opts.count = true;\n      if (opts.includes) {\n        throw new Error('`count` cannot be used with eager fetch of associations.');\n      }\n      return obj.all.apply(obj, [query, opts, callback]);\n    };\n\n    // TODO: Deprecate\n    obj.load = obj.first;\n\n    obj.all = function () {\n      var args = Array.prototype.slice.call(arguments)\n      // Important: do not stub out a callback -- if a callback is\n      // defined, all results of the query will be buffered\n        , callback = typeof args[args.length - 1] == 'function' ?\n              args.pop() : null\n        , query = args.shift() || {}\n        , opts = args.shift() || {}\n        , adapt;\n\n      opts.scenario = opts.scenario || 'reify';\n\n      query = new Query(model[name], query, opts);\n\n      adapt = model.getAdapterForModel(name);\n      if (opts.includes && adapt.type != 'sql') {\n        throw new Error('Only SQL adapters support ' +\n            'the \"includes\" option for queries.');\n      }\n\n      return adapt.load.apply(adapt, [query, callback]);\n    };\n\n    obj.save = function () {\n      var args = Array.prototype.slice.call(arguments)\n        , beforeSaveArgs = args.slice()\n        , emitFunc = function () {\n            model[name].emit.apply(model[name], beforeSaveArgs);\n          }\n        , data = args.shift()\n        , callback = args.pop() || function () {}\n        , opts = args.shift() || {}\n        , adapt\n        , saved\n        , item\n        , isCollection;\n\n      beforeSaveArgs.unshift('beforeSave');\n\n      adapt = model.getAdapterForModel(name);\n\n      isCollection = Array.isArray(data);\n      // Collection\n      // Bulk save only works on new items -- existing item should only\n      // be when doing instance.save because update takes only one set\n      // of edited props to be applied to all items\n      if (isCollection) {\n\n        emitFunc();\n\n        saved = false;\n        for (var i = 0, ii = data.length; i < ii; i++) {\n          item = data[i];\n          if (item._saved) {\n            return callback(new Error('A bulk-save can only have new ' +\n                'items in it.'), null);\n          }\n          // Bail out if any instance isn't valid and no force flag\n          if (!(item.isValid() || opts.force)) {\n            return callback(item.errors, null);\n          }\n        }\n      }\n      // Single item\n      else {\n\n        saved = data._saved;\n        // Bail out if instance isn't valid\n        if (!(data.isValid() || opts.force)) {\n          return callback(data.errors, null);\n        }\n        // Already existing instance, use update\n        if (saved) {\n          if (model.config.useTimestamps) {\n            data.updatedAt = new Date();\n          }\n          // Re-route to update\n          return obj.update.apply(obj, [data, {id: data.id},\n              opts, callback]);\n        }\n\n        if (typeof data.beforeSave === 'function') {\n          data.beforeSave();\n        }\n        data.emit('beforeSave');\n        emitFunc();\n      }\n\n      return adapt.insert.apply(adapt, [data, opts, function (err, res) {\n        if (!err) {\n          model[name].emit('save', res);\n          if (!isCollection) {\n            if (typeof data.afterSave === 'function') {\n              data.afterSave();\n            }\n\n            data.emit('save');\n          }\n        }\n        callback(err, res);\n      }]);\n    };\n\n    obj.update = function () {\n      var args = Array.prototype.slice.call(arguments)\n        , data\n        , callback\n        , query\n        , opts\n        , adapt;\n\n      args.unshift('beforeUpdate');\n      model[name].emit.apply(model[name], args);\n      args.shift();\n\n      data = args.shift();\n      callback = args.pop() || function () {};\n      query = args.shift() || {};\n      opts = args.shift() || {};\n\n      if (typeof query == 'string' || typeof query == 'number') {\n        query = {id: query};\n      }\n\n      // Data may by just a bag or params, or an actual instance\n      if (data instanceof model.ModelBase) {\n        // Bail out if instance isn't valid\n        if (!(data.isValid() || opts.force)) {\n          return callback(data.errors, null);\n        }\n        data.emit('beforeUpdate');\n      }\n\n      query = new Query(model[name], query, opts);\n\n      adapt = model.getAdapterForModel(name);\n\n      return adapt.update.apply(adapt, [data, query, function (err, res) {\n        if (!err) {\n          model[name].emit('update', res);\n          // Data may by just a bag or params, or an actual instance\n          if (typeof data.emit == 'function') {\n            if (typeof data.afterUpdate === 'function') {\n              data.afterUpdate();\n            }\n            data.emit('update');\n          }\n        }\n        callback(err, res);\n      }]);\n    };\n\n    obj.remove = function () {\n      var args = Array.prototype.slice.call(arguments)\n        , query\n        , callback\n        , opts\n        , adapt;\n\n      args.unshift('beforeRemove');\n      model[name].emit.apply(model[name], args);\n      args.shift();\n\n      query = args.shift();\n      callback = args.pop() || function () {};\n      opts = args.shift() || {};\n\n      if (typeof query == 'string' || typeof query == 'number') {\n        query = {id: query};\n        opts.limit = 1;\n      }\n\n      query = new Query(model[name], query, opts);\n\n      adapt = model.getAdapterForModel(name);\n\n      return adapt.remove.apply(adapt, [query, function (err, res) {\n        if (!err) {\n          model[name].emit('remove', res);\n        }\n        callback(err, res);\n      }]);\n    };\n\n    obj.getPropertyNames = function () {\n      var reg = model.descriptionRegistry[name]\n        , properties = reg.properties;\n      return Object.keys(properties);\n    };\n\n    obj.modelName = name;\n\n    return obj;\n  };\n\n  this.clearDefinitions = function (defs) {\n    var self = this;\n    defs.forEach(function (m) {\n      // Prefer 'name', accept older 'ctorName'\n      var name = m.name || m.ctorName;\n      // Registration may have happened in the model definition file\n      // if using the old templates. Don't re-register\n      delete self[name];\n    });\n  };\n\n  this.registerDefinitions = function (defs) {\n    var self = this;\n    defs.forEach(function (m) {\n      // Prefer 'name', accept older 'ctorName'\n      var name = m.name || m.ctorName;\n      // Registration may have happened in the model definition file\n      // if using the old templates. Don't re-register\n      if (!self[name]) {\n        self.registerDefinition(name, m.ctor);\n      }\n    });\n    this.createForeignKeys();\n  };\n\n  // Alias to single-def registration method\n  this.register = function (name, ModelDefinition) {\n    return this.registerDefinition(name, ModelDefinition);\n  };\n\n  this.registerDefinition = function (name, ModelDefinition) {\n    var origProto = ModelDefinition.prototype\n      , defined\n      , ModelCtor;\n\n    // Create the place to store the metadata about the model structure\n    // to use to do validations, etc. when constructing\n    model.descriptionRegistry[name] = new model.ModelDescription(name);\n    // Execute all the definition methods to create that metadata\n    ModelDefinition.prototype = new model.ModelDefinitionBase(name);\n    defined = new ModelDefinition();\n\n    // Create the constructor function to use when calling static\n    // ModelCtor.create. Gives them the proper instanceof value,\n    // and .valid, etc. instance-methods.\n    ModelCtor = _createModelItemConstructor(defined);\n\n    // Mix in the static methods like .create and .load\n    utils.mixin(ModelCtor, _createStaticMethodsMixin(name));\n    // Mix on the statics on the definition 'ctor' onto the\n    // instantiated ModelDefinition instance\n    utils.mixin(defined, ModelDefinition);\n    // Mix ModelDefinition instance properties as static properties\n    // for the model item 'ctor'\n    utils.mixin(ModelCtor, defined);\n    // Same with EventEmitter methods\n    utils.enhance(ModelCtor, new EventEmitter());\n\n    // Mix any functions defined directly in the model-item definition\n    // 'constructor' into the original prototype, and set it as the prototype of the\n    // actual constructor\n    utils.mixin(origProto, defined);\n\n    ModelCtor.prototype = new model.ModelBase();\n    // Preserve any inherited shit from the definition proto\n    utils.enhance(ModelCtor.prototype, origProto);\n\n    model[name] = ModelCtor;\n\n    return ModelCtor;\n  };\n\n  this.createItem = function (name, p, o) {\n    var params = p || {}\n      , opts = o || {}\n      , item = new model[name](params);\n\n    // Default to the 'create' scenario\n    opts.scenario = opts.scenario || 'create'\n\n    model[name].emit('beforeCreate', p, o);\n\n    this.validateAndUpdateFromParams(item, params, opts);\n\n    if (this.config.useTimestamps && !item.createdAt) {\n      item.createdAt = new Date();\n    }\n\n    if (typeof item.afterCreate === 'function') {\n      item.afterCreate();\n    }\n    model[name].emit('create', item);\n    return item;\n  };\n\n  this.updateItem = function (item, params, opts) {\n    var data = {}\n      , name = item.type\n      , opts = opts || {};\n\n    // Default to the 'update' scenario\n    opts.scenario = opts.scenario || 'update'\n\n    model[name].emit('beforeUpdateProperties', item, params, opts);\n    item.emit('beforeUpdateProperties');\n\n    utils.mixin(data, item);\n    utils.mixin(data, params);\n    this.validateAndUpdateFromParams(item, data, opts);\n\n    if (typeof item.afterUpdateProperties === 'function') {\n      item.afterUpdateProperties();\n    }\n\n    model[name].emit('updateProperties', item);\n    item.emit('updateProperties');\n\n    return item;\n  };\n\n  this.validateAndUpdateFromParams = function (item, passedParams, opts) {\n    var params\n      , name = item.type\n      , type = model.descriptionRegistry[name]\n      , properties = type.properties\n      , validated = null\n      , errs = null\n      , camelizedKey\n      , skip = opts.skip\n      , scenario = opts.scenario\n      , skipKeys = {}\n      , val;\n\n    if (typeof item.beforeValidate === 'function') {\n      item.beforeValidate(passedParams);\n    }\n    item.emit('beforeValidate')\n    model[name].emit('beforeValidate', item, passedParams);\n\n    // May be revalidating, clear errors\n    delete item.errors;\n\n    // Convert snake_case names in params to camelCase\n    if (this.config.forceCamel) {\n      params = {};\n      for (var p in passedParams) {\n        // Allow leading underscores in the keys for pseudo-privates\n        camelizedKey = utils.string.camelize(p, {leadingUnderscore: true});\n        params[camelizedKey] = passedParams[p];\n      }\n    }\n    else {\n      params = passedParams;\n    }\n\n    // User-input should never contain these -- but we still want\n    // to validate them to make sure the format didn't get fucked up\n    if (typeof item.createdAt != 'undefined') {\n      params.createdAt = item.createdAt;\n    }\n    if (typeof item.updatedAt != 'undefined') {\n      params.updatedAt = item.updatedAt;\n    }\n\n    if (skip) {\n      for (var i in skip) {\n        skipKeys[skip[i]] = true;\n      }\n    }\n\n    for (var p in properties) {\n      if (skipKeys[p]) {\n        continue;\n      }\n\n      validated = this.validateProperty(properties[p], params, {scenario: scenario});\n      // If there are any failed validations, the errs param\n      // contains an Object literal keyed by field name, and the\n      // error message for the first failed validation for that\n      // property\n      // Use raw, invalid value on the instance\n      if (validated.err) {\n        errs = errs || {};\n        errs[p] = validated.err;\n        item[p] = params[p];\n      }\n      // Otherwise add the type-coerced, valid value to the return item\n      else {\n        item[p] = validated.val;\n      }\n    }\n\n    // Should never have been incuded in user input, so safe to\n    // rm these from the params\n    delete params.createdAt;\n    delete params.updatedAt;\n\n    if (errs) {\n      item.errors = errs;\n    }\n\n    if (typeof item.afterValidate === 'function') {\n      item.afterValidate();\n    }\n\n    item.emit('validate')\n    model[name].emit('validate', item);\n\n    return item;\n  };\n\n  this.validateProperty = function (prop, params, opts) {\n\n    var options = opts || {}\n      , name = prop.name\n      , val = params[name]\n      , datatypeName = prop.datatype.toLowerCase()\n      , datatypeValidator = this.datatypes[datatypeName].validate\n      , result\n      , scenario = opts.scenario\n      , locale = options.locale || utils.i18n.getDefaultLocale();\n\n    // Validate for the base datatype only if there actually is a value --\n    // e.g., undefined will fail the validation for Number, even if the\n    // field is optional\n    if (!utils.isEmpty(val)) {\n      // 'Any' datatype\n      if (prop.datatype == '*') {\n        result = {\n          val: val\n        };\n      }\n      // Specific datatype -- perform validation/type-coercion\n      else {\n        result = datatypeValidator(name, val, locale);\n        if (result.err) {\n          return {\n            err: result.err,\n            val: null\n          };\n        }\n      }\n      // Value may have been modified in the datatype check -- e.g.,\n      // 'false' changed to false, '8.0' changed to 8, '2112' changed to\n      // 2112, etc.\n      val = result.val;\n    }\n\n    // Now go through all the base validations for this property\n    var validations = prop.validations\n      , validator\n      , err\n      , rule;\n\n    for (var p in validations) {\n      validator = model.validators[p]\n      rule = utils.mixin({}, validations[p], {scenario: opts.scenario});\n\n      if (typeof validator != 'function') {\n        throw new Error(p + ' is not a valid validator');\n      }\n\n      err = validator(name, val, params, rule, locale);\n      // If there's an error for a validation, don't bother\n      // trying to continue with more validations -- just return\n      // this first error message\n      if (err) {\n        return {\n          err: err,\n          val: null\n        };\n      }\n    }\n\n    // If there weren't any errors, return the value for this property\n    // and no error\n    return {\n      err: null,\n      val: val\n    };\n  };\n\n  this.createAdapter = function (name, config) {\n    return adapters.create(name, config);\n  };\n\n  this.getAdapterInfo = function (name) {\n    return adapters.getAdapterInfo(name);\n  };\n\n  this.getAdapterForModel = function (modelName) {\n    var ctor = this[modelName]\n      , adapter = (ctor && ctor.adapter) || this.defaultAdapter;\n    if (!adapter) {\n      throw new Error('No adapter found for ' + modelName +\n          '. Please define one with `setAdapter`, or define a default' +\n          ' adapter with `model.setDefaultAdapter`.');\n    }\n    return adapter;\n  };\n\n  this.setDefaultAdapter = function (name, config) {\n    var adapter = adapters.create(name, config);\n    this.defaultAdapter = adapter;\n  };\n\n  // FIXME: Move this into an associations lib\n  this.getAssociation = function (main, assn) {\n    var mainName = utils.string.getInflection(main, 'constructor', 'singular')\n      , assnName = utils.string.getInflection(assn, 'constructor', 'singular')\n      , assn\n      , assnItem;\n    assn = this.descriptionRegistry[mainName].associations;\n    for (var p in assn) {\n      assnItem = assn[p][assnName];\n      if (assnItem) {\n        return assnItem;\n      }\n    }\n  };\n\n  this.getAssociationType = function (main, assn) {\n    var mainName = utils.string.getInflection(main, 'constructor', 'singular')\n      , assnName = utils.string.getInflection(assn, 'constructor', 'singular')\n      , assn\n      , assnItem;\n    assn = this.descriptionRegistry[mainName].associations;\n    for (var p in assn) {\n      assnItem = assn[p][assnName];\n      if (assnItem) {\n        return p;\n      }\n    }\n  };\n\n  this.getModelByName = function (name) {\n    return this[name];\n  };\n\n  this.createForeignKeys = function () {\n    var creator;\n    while((creator = _foreignKeyCreators.pop())) {\n      creator();\n    }\n  };\n\n  this.setLocalRequireError = function (msg) {\n    this.localRequireError = msg;\n  };\n\n})());\n\nmodel.ModelDefinitionBase = function (name) {\n  var self = this\n    , reg = model.descriptionRegistry\n    , _createValidator = function (p) {\n        return function () {\n          var args = Array.prototype.slice.call(arguments);\n          args.unshift(p);\n          return self.validates.apply(self, args);\n        };\n      };\n\n  this.name = name;\n\n  this.setAdapter = function (name, config) {\n    var adapter = adapters.create(name, config);\n    this.adapter = adapter;\n  };\n\n  this.property = function (name, datatype, options) {\n    var opts = options || {};\n\n    // Don't allow users to define properties with the same\n    // name as magical system properties\n    if (!opts.isSystem && _systemProperties[name]) {\n      throw new Error('You cannot define the property \"' + name +\n          '\" on a model, as it\\'s a reserved system-property name.');\n    }\n\n    reg[this.name].properties[name] =\n      new model.PropertyDescription(name, datatype, opts);\n  };\n\n  this.defineProperties = function (obj) {\n    var type\n      , options\n      , property;\n\n    for (var name in obj) {\n      property = obj[name];\n\n      if (typeof property === 'string') {\n        type = property;\n        options = {};\n      }\n      else {\n        type = property.type;\n        options = property;\n      }\n\n      this.property(name, type, options);\n    }\n  }\n\n  // (condition, name, [reference], [opts])\n  this.validates = function () {\n    var args = Array.prototype.slice.call(arguments)\n      , arg\n      , condition = args.shift()\n      , name = args.shift()\n      , reference\n      , opts = {};\n    while ((arg = args.pop())) {\n      // Regex for validatesFormat or function for validatesWithFunction\n      // or string param name for validatesConfirmed\n      if (arg instanceof RegExp || typeof arg == 'function' ||\n          typeof arg == 'string') {\n        reference = arg;\n      }\n      else {\n        opts = utils.mixin(opts, arg);\n      }\n    }\n\n    // Old API allows passing simple number to validatesLength\n    if (!isNaN(opts)) {\n      opts = {is: opts};\n    }\n\n    // Default to 'create' and 'update' only for scenarios\n    opts.on = opts.on || ['create', 'update'];\n\n    if (typeof reg[this.name].properties[name] === 'undefined') {\n      throw new Error('Validation cannot be added for \"' + name +\n                      '\": property does not exist on the ' + this.name +\n                      ' model.');\n    }\n\n    reg[this.name].properties[name].validations[condition] =\n        new model.ValidationDescription(condition, reference, opts);\n  };\n\n  // For each of the validators, create a validatesFooBar from\n  // validates('fooBar' ...\n  for (var p in model.validators) {\n    this['validates' + utils.string.capitalize(p)] = _createValidator(p);\n  }\n\n  // Add the base model properties -- these should not be handled by user input\n  if (model.config.useTimestamps) {\n    this.property('createdAt', 'datetime', {isSystem: true});\n    this.property('updatedAt', 'datetime', {isSystem: true});\n  }\n\n  ['hasMany', 'hasOne', 'belongsTo'].forEach(function (assnKey) {\n    self[assnKey] = function (name, options) {\n      var opts = options || {}\n        , assn = reg[self.name].associations[assnKey] || {}\n        , assnName = name\n        , modelName = opts.model || name;\n\n      // Normalize inflection; we don't care which they use\n      assnName = utils.string.getInflection(assnName, 'constructor', 'singular');\n      modelName = utils.string.getInflection(modelName, 'constructor', 'singular');\n\n      assn[assnName] = {\n        name: assnName\n      , model: modelName\n      , through: opts.through\n      , type: assnKey\n      };\n\n      reg[self.name].associations[assnKey] = assn;\n\n      // Set up foreign keys\n      var createForeignKey = function (assnName) {\n        return function () {\n          var ownerModelName\n            , ownedModelName\n            , idKey\n            , datatype\n            , def;\n\n          if (assnKey == 'belongsTo') {\n            ownerModelName = modelName;\n            ownedModelName = self.name;\n            idKey = modelName;\n          }\n          else {\n            ownerModelName = self.name;\n            ownedModelName = modelName;\n            idKey = self.name;\n          }\n\n          if (assnName == modelName) {\n            idKey = utils.string.decapitalize(idKey) + 'Id'\n          }\n          else {\n            idKey = utils.string.decapitalize(assnName) + idKey  + 'Id'\n          }\n\n          if (!reg[ownedModelName]) {\n            throw new Error('Model ' + ownedModelName + ' does not exist.');\n          }\n\n          if (!reg[ownedModelName].properties[idKey]) {\n            def = model[ownerModelName];\n            datatype = model.config.autoIncrementId ? 'int' : 'string';\n\n            reg[ownedModelName].properties[idKey] =\n              new model.PropertyDescription(idKey, datatype);\n          }\n        }\n      };\n\n      // Set up foreign keys except in the case of virtual 'throughs'\n      // FIXME: Hack, let other models get defined first\n      // Should probably listen for an event that signals\n      // base models are set up\n      if (!opts.through) {\n        _foreignKeyCreators.push(createForeignKey(assnName));\n      }\n    };\n  });\n};\n\nmodel.ModelDescription = function (name) {\n  this.name = name;\n  this.properties = {};\n  this.associations = {};\n};\n\nmodel.PropertyDescription = function (name, datatype, o) {\n  var opts = o || {}\n    , validations = {}\n    , validationOpts = utils.mixin({}, opts);\n\n  delete validationOpts.required;\n  delete validationOpts.length;\n  delete validationOpts.format;\n\n  this.name = name;\n  this.datatype = datatype;\n  this.options = opts;\n\n  // Creates results similar to `this.validates`, above in ModelDefinitionBase\n  // Would be great to remove the duplication of logic\n  for (var p in opts) {\n    if (opts.required || opts.length) {\n      validations.present =\n          new model.ValidationDescription('present', null, validationOpts);\n    }\n    if (opts.length) {\n      if (typeof opts.length == 'object') {\n      // {min: 1, max: 2} or {is: 3}\n      validations.length =\n          new model.ValidationDescription('length', null,\n              utils.mixin(opts.length, validationOpts));\n      }\n      // 1 or '1'\n      else {\n      validations.length =\n          new model.ValidationDescription('length', null,\n              utils.mixin({is: opts.length}, validationOpts));\n      }\n    }\n    if (opts.format) {\n      validations.format =\n          new model.ValidationDescription('length', opts.format,\n              validationOpts);\n    }\n  }\n  this.validations = validations;\n};\n\nmodel.ValidationDescription = function (type, reference, opts) {\n  this.type = type;\n  this.reference = reference;\n  this.opts = opts || {};\n};\n\nmodule.exports = model;\n\n// Load last, these depend on index.js\nQuery = require('./query/query').Query;\nmodel.datatypes = require('./datatypes');\nassociation = require('./association');\n\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/base_config.js":"\nvar config = {\n  useTimestamps: true\n, useUTC: true\n, forceCamel: true\n, autoIncrementId: false\n, defaultAdapter: null\n};\n\nmodule.exports = config;\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/adapters/index.js":"\nvar adapters\n  , path = require('path')\n  , _aliases\n  , _adapters\n  , _paths;\n\n_aliases = {\n  postgres: 'postgres'\n, pg: 'postgres'\n, postgresql: 'postgres'\n, mysql: 'mysql'\n, sqlite: 'sqlite'\n, riak: 'riak'\n, mongo: 'mongo'\n, mongodb: 'mongo'\n, memory: 'memory'\n, filesystem: 'filesystem'\n, level: 'level'\n};\n\n_adapters = {\n  postgres: {\n    path: 'sql/postgres'\n  , lib: 'pg'\n  , type: 'sql'\n  }\n, mysql: {\n    path: 'sql/mysql'\n  , lib: 'mysql'\n  , type: 'sql'\n  }\n, sqlite: {\n    path: 'sql/sqlite'\n  , lib: 'sqlite3'\n  , type: 'sql'\n  }\n, riak: {\n    path: 'riak/index'\n  , lib: null\n  , type: 'nosql'\n  }\n, mongo: {\n    path: 'mongo/index'\n  , lib: 'mongodb'\n  , type: 'nosql'\n  }\n, memory: {\n    path: 'memory/index'\n  , lib: null\n  , type: 'nosql'\n  }\n, filesystem: {\n    path: 'filesystem/index'\n  , lib: null\n  , type: 'nosql'\n  }\n, level: {\n    path: 'level/index'\n  , lib: 'level'\n  , type: 'nosql'\n  }\n};\n\nfor (var p in _adapters) {\n  _adapters[p].name = p;\n}\n\nadapters = new (function () {\n\n  this.getAdapterInfo = function (adapter) {\n    var canonical = _aliases[adapter]\n      , adapter = _adapters[canonical];\n    return adapter || null;\n  };\n\n  this.create = function (name, config) {\n    var info = this.getAdapterInfo(name)\n      , ctorPath\n      , ctor;\n\n    if (!info) {\n      throw new Error('\"' + name + '\" is not a valid adapter.');\n    }\n\n    ctorPath = path.join(__dirname, info.path)\n    ctor = require(ctorPath).Adapter;\n\n    return new ctor(config || {});\n  };\n\n})();\n\nmodule.exports = adapters;\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/validators.js":"/*\n * Geddy JavaScript Web development framework\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nvar utils = require('utilities')\n  , i18n = utils.i18n\n  , validators = {}\n  , baseValidators\n  , createScenarioWrappedValidator;\n\n/*\n * Basic validators -- name is the field name, params is the entire params\n * collection (needed for stuff like password confirmation so it's possible\n * to compare with other field values, and the rule is the data for this\n * particular validation\n * Rules can look like this:\n * present: {opts: {message: 'Gotta be here'}}\n * length: {opts: {min: 2, max: 12}}\n * withFunction: {reference: function (s) { return true },\n *    message: 'Something is wrong'}\n */\nbaseValidators = {\n  present: function (name, val, params, rule, locale) {\n    var msg;\n    if (utils.isEmpty(val)) {\n      //'Field \"' + name + '\" is required.';\n      msg = rule.opts.message || i18n.getText('model.validatesPresent',\n        {name: name}, locale);\n    }\n    return msg;\n  },\n\n  absent: function (name, val, params, rule, locale) {\n    var msg;\n    if (val) {\n      //return rule.opts.message || 'Field \"' + name + '\" must not be filled in.';\n      msg = rule.opts.message || i18n.getText('model.validatesAbsent',\n        {name: name}, locale);\n    }\n    return msg;\n  },\n\n  confirmed: function (name, val, params, rule, locale) {\n    var qual = rule.reference\n      , msg;\n    if (val != params[qual]) {\n      //return rule.opts.message || 'Field \"' + name + '\" and field \"' + qual +\n      //    '\" must match.';\n      msg = rule.opts.message || i18n.getText('model.validatesConfirmed',\n        {name: name, qual: qual}, locale);\n    }\n    return msg;\n  },\n\n  format: function (name, val, params, rule, locale) {\n    var msg;\n    if (!rule.reference.test(val)) {\n      //return rule.opts.message || 'Field \"' + name + '\" is not correctly formatted.';\n      msg = rule.opts.message || i18n.getText('model.validatesFormat',\n        {name: name}, locale);\n    }\n    return msg;\n  },\n\n  length: function (name, val, params, rule, locale) {\n    var qual = rule.opts\n      , validQualifier = false\n      , err\n      , msg\n      , numVal\n      , errMsg = 'validatesLength must be set to a integer ' +\n            'or object with min/max integer properties.';\n\n    // If a specific length is wanted, there has to be a value\n    // in the first place\n    if (!val) {\n      return rule.opts.message || i18n.getText('model.validatesPresent', {name: name}, locale);\n    }\n\n    // Validate that there's a opts to check against\n    if (!qual) {\n      throw new Error(errMsg);\n    }\n\n    // Check if using old API of passing just a number\n    if (typeof qual != 'object') {\n      qual = {is: qual};\n    }\n\n    // First check for an exact length qualifier\n    numVal = parseFloat(qual.is);\n    if (!isNaN(numVal)) {\n      validQualifier = true;\n      if (val.length !== numVal) {\n        msg = rule.opts.message || i18n.getText('model.validatesExactLength',\n          {name: name, is: qual.is}, locale);\n      }\n    }\n    else {\n      numVal = parseFloat(qual.min);\n      if (!isNaN(numVal)) {\n        validQualifier = true;\n        if (val.length < numVal) {\n          msg = rule.opts.message || i18n.getText('model.validatesMinLength',\n            {name: name, min: qual.min}, locale);\n        }\n      }\n      // Still valid, check for a max\n      if (!msg) {\n        numVal = parseFloat(qual.max);\n        if (!isNaN(numVal)) {\n          validQualifier = true;\n          if (val.length > numVal) {\n          msg = rule.opts.message || i18n.getText('model.validatesMaxLength',\n            {name: name, max: qual.max}, locale);\n          }\n        }\n      }\n    }\n\n    if (!validQualifier) {\n      throw new Error(errMsg);\n    }\n\n    return msg;\n  },\n\n  withFunction: function (name, val, params, rule, locale) {\n    var func = rule.reference\n      , msg;\n    if (typeof func != 'function') {\n      throw new Error('withFunction validator for field \"' + name +\n          '\" must be a function.');\n    }\n    \n    var resultValidation = func(val, params);\n    if (typeof resultValidation === typeof \"\") {\n      msg = resultValidation;\n    } \n    else if (!resultValidation) {\n        //return rule.opts.message || 'Field \"' + name + '\" is not valid.';\n        msg = rule.opts.message || i18n.getText('model.validatesWithFunction',\n          {name: name}, locale);\n    }\n\n    return msg;\n  }\n};\n\ncreateScenarioWrappedValidator = function (baseValidator) {\n  return function (name, val, params, rule, locale) {\n    var validScenarios = rule.opts && rule.opts.on\n      , scenario = rule.scenario\n      , shouldValidate = false;\n\n    // By default, we should validate on all scenarios\n    if (!validScenarios) {\n      shouldValidate = true;\n    }\n\n    // If the user specified scenarios\n    if (!shouldValidate) {\n      // Accept strings too\n      if (! validScenarios instanceof Array) {\n        validScenarios = [validScenarios];\n      }\n\n      // Normalize the input\n      for(var i=0, ii=validScenarios.length; i < ii; i++) {\n        validScenarios[i] = validScenarios[i].toLowerCase();\n      }\n\n      // Scenario might be undefined here, but don't hide the error as\n      // we should always validate with a scenario in mind lest something\n      // unexpected happen.\n      shouldValidate = validScenarios.indexOf(scenario.toLowerCase()) >= 0;\n    }\n\n    if (shouldValidate) {\n      return baseValidator(name, val, params, rule, locale);\n    }\n    else {\n      return null;\n    }\n  }\n};\n\n// Wrap all the base validators in a scenario-aware wrapper\nfor (var key in baseValidators) {\n  validators[key] = createScenarioWrappedValidator(baseValidators[key]);\n}\n\nmodule.exports = validators;\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/formatters.js":"\nvar formatters = new function () {\n  this.date = function (val) {\n    return geddy.date.strftime(val, geddy.config.dateFormat);\n  };\n\n  this.time = function (val) {\n    return geddy.date.strftime(val, geddy.config.timeFormat);\n  };\n\n}();\n\nmodule.exports = formatters;\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/migration/index.js":"var Migration = require('./migration').Migration;\n\nvar migration = new (function () {\n\n\n})();\n\nmigration.Migration = Migration;\n\nmodule.exports = migration;\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/migration/migration.js":"\nvar utils = require('utilities')\n  , Generator = require('../generators/sql').Generator\n  , Migration\n  , Columnator\n  , defaultAdapter = null;\n\nMigration = function (name, adapter) {\n  this.name = name;\n  this.adapter = adapter || defaultAdapter;\n  this.generator = this.adapter.generator;\n};\n\nMigration.prototype = new (function () {\n\n  this.up = function (next) {\n    next();\n  };\n\n  this.down = function (next) {\n    next();\n  };\n\n  // ALTER TABLE distributors ADD COLUMN address varchar(30);\n  this.addColumn = function (/* table, column, datatype, [options], cb*/) {\n    var args = Array.prototype.slice.call(arguments)\n      , sql = ''\n      , table = args.shift()\n      , column = args.shift()\n      , datatype = args.shift()\n      , cb = args.pop()\n      , opts = args.pop() || {} // Optional\n\n    sql = this.generator.alterTableStatement(table, {\n      operation: 'add'\n    , property: {\n        name: column\n      , datatype: datatype\n      }\n    });\n    this.adapter.exec(sql, cb);\n  };\n\n  // ALTER TABLE distributors DROP COLUMN address;\n  this.removeColumn = function (table, column, cb) {\n    var sql = this.generator.alterTableStatement(table, {\n      operation: 'drop'\n    , property: {\n        name: column\n      }\n    });\n    this.adapter.exec(sql, cb);\n  };\n\n  // TODO\n  this.addIndex = function (table, column, options, cb) {};\n\n  // ALTER TABLE distributors ALTER COLUMN address TYPE varchar(30);\n  this.changeColumn = function (table, column, datatype, options, cb) {\n    var args = Array.prototype.slice.call(arguments)\n      , sql = ''\n      , table = args.shift()\n      , column = args.shift()\n      , datatype = args.shift()\n      , cb = args.pop()\n      , opts = args.pop() || {} // Optional\n\n    sql = this.generator.alterTableStatement(table, {\n      operation: 'alter'\n    , property: {\n        name: column\n      , datatype: datatype\n      }\n    });\n    this.adapter.exec(sql, cb);\n  };\n\n  // ALTER TABLE distributors RENAME COLUMN address TO city;\n  this.renameColumn = function (table, column, newColumn, cb) {\n    var sql = this.generator.alterTableStatement(table, {\n      operation: 'rename'\n    , property: {\n        name: column\n      , newName: newColumn\n      }\n    });\n    this.adapter.exec(sql, cb);\n  };\n\n  // CREATE TABLE distributors (did integer, name varchar(40));\n  this.createTable = function (/*name, [opts], [definition], cb*/) {\n    // FIXME: Shouldn't have to late-require 'model' here\n    // Why is order of loading a problem here?\n    var model = require('../index')\n      , args = Array.prototype.slice.call(arguments)\n      , arg\n      , sql = ''\n      , name = args.shift()\n      , opts = {}\n      , definition = function () {}\n      , cb = args.pop()\n      , col = new Columnator();\n\n    // Optional opts/callback or callback/opts\n    while ((arg = args.pop())) {\n      if (typeof arg == 'function') {\n        definition = arg;\n      }\n      else {\n        opts = arg;\n      }\n    }\n\n    definition(col);\n\n    if (model.config.useTimestamps) {\n      col.cols.createdAt = {\n        name: 'createdAt'\n      , datatype: 'datetime'\n      };\n      col.cols.updatedAt = {\n        name: 'updatedAt'\n      , datatype: 'datetime'\n      };\n    }\n\n    sql = this.generator.createTableStatement(name, col.cols);\n    this.adapter.exec(sql, cb);\n  };\n\n  // DROP TABLE IF EXISTS distributors;\n  this.dropTable = function (name, cb) {\n    var sql = this.generator.dropTableStatement(name);\n    this.adapter.exec(sql, cb);\n  };\n\n  // TODO\n  this.removeIndex = function (table, column, cb) {};\n\n})();\n\nMigration.setDefaultAdapter = function (adapter) {\n  defaultAdapter = adapter;\n};\n\nColumnator = function () {\n  this.cols = {};\n};\nColumnator.prototype = new (function () {\n\n  this.column = function (name, datatype) {\n    this.cols[name] = {\n      name: name\n    , datatype: datatype\n    };\n  };\n\n})();\n\nexports.Migration = Migration;\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/generators/sql.js":"var utils = require('utilities')\n  , StandardGenerator\n  , MySQLGenerator\n  , PostgresGenerator\n  , SQLiteGenerator\n  , datatypeMap\n  , generatorMap;\n\n// TODO Better map, SQL-implementation specific\ndatatypeMap = {\n  'string': 'VARCHAR(255)'\n, 'text': 'TEXT'\n, 'number': 'REAL'\n, 'int': 'INTEGER'\n, 'boolean': 'BOOLEAN'\n, 'date': 'DATE'\n, 'datetime': 'TIMESTAMP'\n, 'time': 'TIME'\n, 'object': 'TEXT'\n};\n\nStandardGenerator = function () {\n  this._datatypes = utils.mixin({}, datatypeMap);\n  this.COLUMN_NAME_DELIMITER = '\"';\n};\n\nStandardGenerator.prototype = new (function () {\n\n  this.getDatatype = function (jsType) {\n    return this._datatypes[jsType];\n  };\n\n  this.addColumnStatement = function (prop, options) {\n    var sql = 'ADD COLUMN '\n      , opts = options || {}\n      , delimiter = this.COLUMN_NAME_DELIMITER;\n      sql += delimiter + utils.string.snakeize(prop.name) + delimiter;\n      if (prop.datatype) {\n        sql += ' ' + this.getDatatype(prop.datatype);\n      }\n      if (opts.append) {\n        sql += ' ' + opts.append;\n      }\n      return sql;\n  };\n\n  this.dropColumnStatement = function (prop) {\n    var sql = 'DROP COLUMN '\n      , delimiter = this.COLUMN_NAME_DELIMITER;\n    sql += delimiter + utils.string.snakeize(prop.name) + delimiter;\n    return sql;\n  };\n\n  this.alterColumnStatement = function (prop) {\n    var sql = 'ALTER COLUMN '\n      , delimiter = this.COLUMN_NAME_DELIMITER;\n    sql += delimiter + utils.string.snakeize(prop.name) + delimiter + ' ';\n    sql += 'TYPE ' + this.getDatatype(prop.datatype);\n    return sql;\n  };\n\n  this.renameColumnStatement = function (prop) {\n    var sql = 'RENAME COLUMN '\n      , delimiter = this.COLUMN_NAME_DELIMITER;\n    sql += delimiter + utils.string.snakeize(prop.name) + delimiter + ' ';\n    sql += 'TO ' + delimiter + utils.string.snakeize(prop.newName) + delimiter;\n    return sql;\n  };\n\n  // CREATE TABLE distributors (did integer, name varchar(40));\n  this.createTableStatement = function (name, props, options) {\n    var model = require('../index')\n      , sql = ''\n      , opts = options || {}\n      , tableName\n      , idCol\n      , propArr = [];\n\n    tableName = utils.string.getInflection(name, 'filename', 'plural');\n\n    sql += 'CREATE TABLE ' + tableName + ' (';\n\n    // Use DB auto-increment\n    // FIXME: Is this syntax Postgres-specific?\n    if (model.config.autoIncrementId) {\n      idCol = this.addColumnStatement({\n        name: 'id'\n      }, {append: 'BIGSERIAL PRIMARY KEY'});\n    }\n    // Use string UUIDs\n    else {\n      idCol = this.addColumnStatement({\n        name: 'id'\n      , datatype: 'string'\n      }, {append: 'PRIMARY KEY'});\n    }\n    propArr.push(idCol);\n\n    for (var p in props) {\n      propArr.push(this.addColumnStatement(props[p]));\n    }\n    sql += propArr.join(', ');\n    sql += ');';\n    // Strip out the ADD COLUMN commands, which are implicit\n    // in a CREATE TABLE\n    sql = sql.replace(/ADD COLUMN /g, '');\n    return sql;\n  };\n\n  this.alterTableStatement = function (name, alterations, options) {\n    var self = this\n      , sql = ''\n      , opts = options || {}\n      , alter = Array.isArray(alterations) ? alterations : [alterations]\n      , alterArr = []\n      , tableName;\n\n    tableName = utils.string.getInflection(name, 'filename', 'plural');\n    sql += 'ALTER TABLE ' + tableName + ' ';\n\n    // {operation: 'add', property: {name: 'foo', datatype: 'string'}}\n    alter.forEach(function (item) {\n      alterArr.push(self[item.operation + 'ColumnStatement'](item.property));\n    });\n    sql += alterArr.join(', ');\n    sql += ';';\n    return sql;\n  };\n\n  this.dropTableStatement = function (name) {\n    var sql = ''\n      , tableName = utils.string.getInflection(name, 'filename', 'plural');\n    sql += 'DROP TABLE IF EXISTS ' + tableName + '; ';\n    return sql;\n  };\n\n  this.createTable = function (modelNames) {\n    var model = require('../index')\n      , self = this\n      , sql = ''\n      , reg = model.descriptionRegistry\n      , props\n      , names = Array.isArray(modelNames) ?\n            modelNames : [modelNames];\n    names.forEach(function (name) {\n      props = reg[name].properties;\n      sql += self.createTableStatement(name, props);\n    });\n    return sql;\n  };\n\n  this.dropTable = function (modelNames) {\n    var self = this\n      , sql = ''\n      , names = Array.isArray(modelNames) ?\n            modelNames : [modelNames];\n    names.forEach(function (name) {\n      sql += self.dropTableStatement(name);\n    });\n    return sql;\n  };\n\n})();\n\nPostgresGenerator = function () {\n  StandardGenerator.call(this);\n  this._datatypes = utils.mixin({}, datatypeMap);\n  utils.mixin(this._datatypes, {\n    'int': 'BIGINT'\n  , 'object': 'JSON'\n  });\n};\nPostgresGenerator.prototype = Object.create(StandardGenerator.prototype);\n\nMySQLGenerator = function () {\n  StandardGenerator.call(this);\n  this._datatypes = utils.mixin({}, datatypeMap);\n  utils.mixin(this._datatypes, {\n    'int': 'BIGINT'\n  , 'datetime': 'TIMESTAMP NULL'\n  });\n  this.COLUMN_NAME_DELIMITER = '`';\n};\nMySQLGenerator.prototype = Object.create(StandardGenerator.prototype);\nMySQLGenerator.prototype.alterColumnStatement = function (prop) {\n  var sql = 'MODIFY COLUMN '\n    , delimiter = this.COLUMN_NAME_DELIMITER;\n  sql += delimiter + utils.string.snakeize(prop.name) + delimiter + ' ';\n  sql += this.getDatatype(prop.datatype);\n  return sql;\n};\n\nSQLiteGenerator = function () {\n  StandardGenerator.call(this);\n};\nSQLiteGenerator.prototype = Object.create(StandardGenerator.prototype);\nSQLiteGenerator.prototype.alterColumnStatement = function (prop) {\n  var msg = 'Sorry, SQLite does not support ALTER COLUMN: ' +\n      'http://www.sqlite.org/lang_altertable.html\\n' +\n      'Please use PostgreSQL or MySQL, ' +\n      'or work around using ADD/REMOVE and a temp column: ' +\n      'http://stackoverflow.com/questions/805363/how-do-i-rename-a-column-in-a-sqlite-database-table';\n  throw new Error(msg);\n};\n\ngeneratorMap = {\n  postgres: PostgresGenerator\n, mysql: MySQLGenerator\n, sqlite: SQLiteGenerator\n};\n\nmodule.exports = {\n  StandardGenerator: StandardGenerator\n, getGeneratorForAdapter: function (adapter) {\n    var ctor = generatorMap[adapter.name];\n    return new ctor();\n  }\n};\n\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/query/query.js":"\nvar query = {}\n  , Query\n  , utils = require('utilities')\n  , model = require('../index')\n  , operation = require('./operation')\n  , comparison = require('./comparison');\n\nQuery = function (model, conditions, options) {\n  this.model = null;\n  this.conditions = null;\n  this.initialize.apply(this, arguments);\n};\n\nQuery.comparisonTypes = {\n  'eql': 'EqualTo'\n, 'ne': 'NotEqualTo'\n, 'in': 'Inclusion'\n, 'like': 'Like'\n, 'gt': 'GreaterThan'\n, 'lt': 'LessThan'\n, 'gte': 'GreaterThanOrEqual'\n, 'lte': 'LessThanOrEqual'\n};\n\nQuery.prototype = new (function () {\n\n  var _operationTypes = {\n        'and': true\n      , 'or': true\n      , 'not': true\n      , 'null': true\n      }\n\n    , _isQueryObject = function (obj) {\n        // Just generic query object -- not null, Date, or Boolean, or Array\n        return (obj && typeof obj == 'object' && !(obj instanceof Date) &&\n            !(obj instanceof Boolean) && !Array.isArray(obj));\n      }\n\n    , _extractComparisonType = function (obj) {\n        // Just generic query object -- not null, Date, or Boolean\n        if (_isQueryObject(obj)) {\n          // Return any valid comparison type used as key\n          for (var p in obj) {\n            if (Query.comparisonTypes[p]) {\n              return p;\n            }\n          }\n        }\n      }\n\n    , _createFieldValidator = function () {\n        var self = this\n          , baseProps = {\n              id: true\n            , createdAt: true\n            , updatedAt: true\n            };\n        return function (k) {\n          var keyName = k\n            , keyNameArr\n            , modelName\n            , reg\n            , assnTokens = [];\n\n          // Users.loginId, Teams.name\n          // Sort on nested association property\n          modelName = self.model.modelName\n\n          // Walks through the associations and updates modelName\n          // until we reach the property name\n          if (keyName.indexOf('.') > -1) {\n            if(self.opts != null && self.opts.limit != null) {\n              throw new Error('It is not possible to query on an association when there is a limit clause')\n            }\n\n            keyNameArr = keyName.split('.');\n\n            while(keyNameArr.length > 1) {\n              var tempAssnName = keyNameArr.shift()\n                , assn = model.getAssociation(modelName, tempAssnName)\n\n              assnTokens.push(tempAssnName)\n\n              if(!assn) {\n                throw new Error('The association \"' + tempAssnName + '\" is not a valid ' +\n                                'property on the ' + modelName + ' model.');\n              }\n              else {\n                modelName = assn.model\n              }\n            }\n\n            keyName = keyNameArr[0]\n          }\n\n          reg = model.descriptionRegistry[modelName].properties;\n\n          if (baseProps[keyName] || reg[keyName]) {\n            return {\n              modelName: modelName\n            , propertyName: keyName\n            , assnTokens: assnTokens\n            };\n          }\n          else {\n            return null;\n          }\n        };\n      }\n\n    , _createOperation = function (conditions, key) {\n        var self = this\n          , type = key || 'and'\n          , cond\n          , item\n          , op = operation.create(type)\n          , notOperand\n          , operand\n          , keys;\n\n        // TODO: Handle associations\n        for (var k in conditions) {\n          cond = conditions[k];\n\n          // Operation type, can contain other operations/conditions\n          if (_operationTypes[k]) {\n            // Base operation-type to create: if the type is a 'not',\n            // create a single 'and' with the same conditions to wrap\n            // in a 'not'\n            type = k == 'not' ? 'and' : k;\n\n            // If the conditions are an array, create a single 'and'\n            // op that wraps each set of conditions in each item, and\n            // add to the wrapper\n            if (Array.isArray(cond)) {\n              // Create empty wrapper\n              operand = operation.create(type);\n              cond.forEach(function (c) {\n                operand.add(_createOperation.apply(self, [c, 'and']));\n              });\n            }\n            // Simple object-literal, just create an operation\n            else {\n              operand = _createOperation.apply(this, [cond, type]);\n            }\n\n            // If this was a 'not' operation, create a wrapping 'not'\n            // to contain the single operation created\n            if (k == 'not') {\n              notOperand = operation.create(k);\n              notOperand.add(operand);\n              operand = notOperand;\n            }\n          }\n          // Condition, may be leaf-node or multiple comparisions\n          // ANDed on the same field\n          else {\n            // Exclude null, exclude array-values, only consider actual objects\n            if (_isQueryObject(cond)) {\n              keys = Object.keys(cond);\n            }\n            // If there are multiple keys, means it's multiple comparisons on\n            // the same field\n            if (keys && keys.length > 1) {\n              // Create wrapper operation\n              operand = operation.create('and');\n              // Go through each of the comparision keys in the object\n              // and create single comparisions which can be ANDed together.\n              // E.g.: {foo: {gte: 1, lte: 5}} =>\n              // {and: [{foo: {gte: 1}}, {foo: {lte: 5}}]}\n              keys.forEach(function (kk) {\n                var q = {};\n                q[k] = {};\n                q[k][kk] = cond[kk];\n                if (!Query.comparisonTypes[kk]) {\n                  throw new Error(kk + ' is not a valid type of comparison');\n                }\n                operand.add(_createOperation.apply(self, [q, 'and']));\n              });\n            }\n            // Simple condition (leaf-node)\n            // {foo: {ne: 'asdf'} or {foo: 1} or {foo: [1, 2, 3]}\n            else {\n              operand = _createComparison.apply(this, [cond, k]);\n            }\n          }\n\n          op.add(operand);\n        }\n        return op;\n      }\n\n    , _createComparison = function (val, key) {\n        var type\n          , keyName = key\n          , keyNameArr\n          , modelName\n          , props\n          , descr\n          , datatype\n          , opts\n          , assnTokens = [];\n\n        modelName = this.model.modelName\n        assnTokens.push(modelName)\n\n        // Walks through the associations and updates modelName\n        // until we reach the property name\n        if (keyName.indexOf('.') > -1) {\n          if(this.opts != null && this.opts.limit != null) {\n            throw new Error('It is not possible to query on an association when there is a limit clause')\n          }\n\n          keyNameArr = keyName.split('.');\n          modelName = this.model.modelName;\n\n          while(keyNameArr.length > 1) {\n            var tempAssnName = keyNameArr.shift()\n              , assn = model.getAssociation(modelName, tempAssnName)\n\n            assnTokens.push(tempAssnName)\n\n            if(!assn) {\n              throw new Error('The association \"' + tempAssnName + '\" is not a valid ' +\n                              'property on the ' + modelName + ' model.');\n            }\n            else {\n              modelName = assn.model\n            }\n          }\n\n          keyName = keyNameArr[0]\n        }\n\n        props = model.descriptionRegistry[modelName].properties;\n        descr = props[keyName];\n\n          // {id: ['foo', 'bar', 'baz']}, shorthand for Inclusion\n        if (Array.isArray(val)) {\n          type = 'in';\n        }\n        else {\n          // Single query objects -- not null, Date, Boolean\n          // e.g., {id: {'like': 'foo'}}\n          type = _extractComparisonType(val);\n          if (type) {\n            val = val[type];\n          }\n          // Simple scalar value, default to equality\n          else {\n            type = 'eql';\n          }\n        }\n\n        // FIXME: How the fuck to handle IDs?\n        // id isn't in the defined props\n        if (keyName == 'id') {\n          if (model.config.autoIncrementId) {\n            datatype = 'int';\n          }\n          else {\n            datatype = 'string';\n          }\n        }\n        else {\n          if (typeof descr === 'undefined') {\n            throw new Error('The property \"' + keyName + '\" is not a valid ' +\n                            'property on the ' + modelName + ' model.');\n          }\n\n          datatype = descr.datatype;\n        }\n\n        opts = _createComparisonOpts.apply(this, [keyName, datatype, assnTokens]);\n\n        // TODO: Validate the value for both the particular field\n        // (e.g., must be a numeric) and the type of comparison\n        // (e.g., 'IN' must be a collection, etc)\n        return comparison.create(Query.comparisonTypes[type], modelName,\n            keyName, val, datatype, opts);\n      }\n\n    , _createComparisonOpts = function (key, datatype, assnTokens) {\n        var opts = this.opts\n          , nocase = opts.nocase\n          , ret = {};\n        if (nocase && (datatype == 'string' || datatype == 'text')) {\n          if (Array.isArray(nocase)) {\n            if (nocase.some(function (o) {\n              return o == key;\n            })) {\n              ret.nocase = true;\n            }\n          }\n          else {\n            ret.nocase = true;\n          }\n        }\n\n        if(Array.isArray(assnTokens) && assnTokens.length) {\n          ret.assnTokens = assnTokens\n        }\n\n        return ret;\n      }\n\n    , _parseOpts = function (options) {\n        var opts = options || {}\n          , ret = {}\n          , val\n          , parsed\n          , validatedField\n          , validated = {}\n          , defaultDir = 'asc';\n        for (var prop in opts) {\n          val = opts[prop];\n          switch (prop) {\n            case 'sort':\n              // 'foo,bar,baz'\n              if (typeof val == 'string') {\n                val = val.split(',');\n              }\n              // ['foo', 'bar', 'baz']\n              if (Array.isArray(val)) {\n                parsed = {};\n                val.forEach(function (v) {\n                  parsed[v] = defaultDir;\n                });\n              }\n              else {\n                parsed = val;\n              }\n              // Now there's a well-formed obj, validate fields\n              for (var p in parsed) {\n                val = parsed[p].toLowerCase();\n                validatedField = this.getValidField(p);\n                if (!validatedField) {\n                  throw new Error(p + ' is not a valid field for ' +\n                      this.model.modelName);\n                }\n                if (!(val == 'asc' || val == 'desc')) {\n                  throw new Error('Sort directon for ' + p +\n                      ' field on ' + validatedField.modelName + ' must be ' +\n                      'either \"asc\" or \"desc\"');\n                }\n                if (validatedField.assnTokens.length) {\n                  var temp = validatedField.assnTokens.concat(validatedField.propertyName).join('.');\n                  validated[temp] = val;\n                }\n                else {\n                  validated[p] = val;\n                }\n              }\n              ret[prop] = validated;\n              break;\n            case 'limit':\n            case 'skip':\n              if (isNaN(val)) {\n                throw new Error('\"' + prop + '\" must be a number.');\n              }\n              ret[prop] = Number(val);\n              break;\n            default:\n              ret[prop] = val;\n          }\n        }\n        return ret;\n      }\n\n    // If there's an 'id' property in the top-level of the query\n    // object, allow non-relational stores to optimize\n    , _isByIdQuery = function (params) {\n        // Don't optimize if there is more than one property\n        if(Object.keys(params).length > 1) {\n          return null;\n        }\n        // Don't optimize if it's a list of ids\n        if (Array.isArray(params.id)) {\n          return null;\n        }\n        return params.id ? params.id : null;\n      };\n\n  this.initialize = function (model, conditionParams, opts) {\n\n    this.model = model;\n    this.byId = _isByIdQuery(conditionParams);\n    this.getValidField = _createFieldValidator.apply(this);\n    this.opts = _parseOpts.apply(this, [opts || {}]);\n    this.conditions = _createOperation.apply(this, [conditionParams]);\n    this.rawConditions = conditionParams;\n  };\n\n})();\n\nquery.Query = Query;\n\nmodule.exports = query;\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/query/operation.js":"var utils = require('utilities')\n  , operation = {}\n  , OperationBase\n  , operationTypes;\n\noperation.create = function () {\n  var args = Array.prototype.slice.call(arguments)\n    , type = args.shift()\n    , ctor = utils.string.capitalize(type) + 'Operation'\n    , inst;\n\n    ctor = operationTypes[ctor];\n    inst = new ctor();\n    inst.type = type;\n    inst.initialize.apply(inst, args);\n    return inst;\n};\n\n\nOperationBase = function () {\n\n  this.initialize = function () {\n    var operands = Array.prototype.slice.call(arguments);\n\n    this.parent = null;\n    this.descendants = [];\n    this.operands = [];\n\n    this.merge(operands);\n  };\n\n  this.forEach = function (f) {\n    this.operands.forEach(f);\n  };\n\n  this.isEmpty = function () {\n    return !this.operands.length;\n  };\n\n  this.isValid = function () {\n    var self = this;\n    return (!this.isEmpty() && this.operands.every(function (op) {\n      return self.validOperand(op);\n    }));\n  };\n\n  this.validOperand = function (op) {\n    return typeof op.isValid == 'function' ?\n      op.isValid() : true;\n  };\n\n  this.add = function (operand) {\n    // Flatten if same type, to create a shallower tree\n    if (operand.type == this.type) {\n      this.merge(operand.operands);\n    }\n    else {\n      this.operands.push(operand);\n      operand.parent = this;\n    }\n  };\n\n  // Can take args or a single array-arg\n  this.merge = function (operands) {\n    var self = this\n      , ops = Array.isArray(operands) ?\n        operands : Array.prototype.slice.call(arguments);\n    ops.forEach(function (op) {\n      self.add(op);\n    });\n  };\n\n  this.union = function (other) {\n    return (create('or', this, other)).minimize();\n  };\n\n  this.intersection  = function () {\n    return (create('and', this, other)).minimize();\n  };\n\n  this.difference = function () {\n    return (create('and', this, create('not', other))).minimize();\n  };\n\n  this.minimize = function () {\n    return this;\n  };\n\n  this.clear = function () {\n    this.operands = [];\n  };\n\n  this.minimizeOperands = function () {\n    var self = this;\n    this.operands = this.operands.map(function (op) {\n      var min = typeof op.minimize == 'function' ?\n          op.minimize() : op;\n      min.parent = self;\n      return min;\n    });\n  };\n\n  this.pruneOperands = function () {\n    this.operands = this.operands.filter(function (op) {\n      return typeof op.isEmpty == 'function' ?\n        !op.isEmpty() : true;\n    });\n  };\n\n  // FIXME: Is this needed?\n  this.isNull = function () {\n    return false;\n  };\n\n};\n\noperationTypes = {\n  AndOperation: function () {\n\n    this.matches = function (record) {\n      return this.operands.every(function (op) {\n        return typeof op.matches == 'function' ?\n          op.matches(record) : true;\n      });\n    };\n\n    this.minimize = function () {\n      this.minimizeOperands();\n\n      if (!this.isEmpty() && this.operands.every(function (op) {\n        return op.isNull();\n      })) {\n        return create('null');\n      }\n\n      this.pruneOperands();\n\n      if (this.operands.length == 1) {\n        return this.operands[0];\n      }\n      return this;\n    };\n  }\n\n, OrOperation: function () {\n\n    this.matches = function (record) {\n      return this.operands.some(function (op) {\n        return typeof op.matches == 'function' ?\n          op.matches(record) : true;\n      });\n    }\n\n    this.isValid = function () {\n      var self = this;\n      return (!this.isEmpty() && this.operands.some(function (op) {\n        return self.validOperand(op);\n      }));\n    };\n\n    this.minimize = function () {\n      this.minimizeOperands();\n\n      if (!this.isEmpty() && this.operands.some(function (op) {\n        return op.isNull();\n      })) {\n        return create('null');\n      }\n\n      this.pruneOperands();\n\n      if (this.operands.length == 1) {\n        return this.operands[0];\n      }\n      return this;\n    };\n  }\n\n, NotOperation: function () {\n    this.add = function (operand) {\n      // Assert there's only one operand\n      if (this.operands.length) {\n        throw new Error('Not operation can only have one operand.');\n      }\n      // Assert that the single operand isn't a self-reference\n      if (this.operand === this) {\n        throw new Error('Operand for Not operation can\\'t be a self-reference.');\n      }\n      this.constructor.prototype.add.apply(this, arguments);\n    };\n\n    this.minimize = function () {\n      var operand\n      this.minimizeOperands();\n      this.pruneOperands();\n      // Try to factor out double negatives\n      operand = this.operand();\n      if (operand && operand instanceof operationTypes.NotOperation) {\n        return this.operands[0].operand;\n      }\n      else {\n        return this;\n      }\n    };\n\n    this.operand = function () {\n      return this.operands.length == 1 && this.operands[0];\n    };\n\n    // FIXME: \"Defaults to false\"?\n    this.isNegated = function () {\n      var parent = this.parent;\n      return !!parent ? parent.isNegated() : true;\n    };\n  }\n\n, NullOperation: function () {\n\n    // TODO: Make sure it's either a Hash or a Resource\n    this.matches = function (resource) {\n      return true;\n    };\n\n    this.isValid = function () {\n      return true;\n    };\n\n    this.isNull = function () {\n      return true;\n    };\n\n  }\n};\n\n(function () {\n  var ctor;\n  for (var t in operationTypes) {\n    ctor = operationTypes[t];\n    ctor.prototype = new OperationBase();\n    ctor.prototype.constructor = ctor;\n  }\n})();\n\n// Export the specific constructors as well as the `create` function\nutils.mixin(operation, operationTypes);\noperation.OperationBase = OperationBase;\n\nmodule.exports = operation;\n\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/query/comparison.js":"var utils = require('utilities')\n  , datatypes = require('../datatypes')\n  , comparison = {}\n  , ComparisonBase\n  , comparisonTypes\n  , _validateForDatatype;\n\n_validateForDatatype = function (val) {\n  var validator = datatypes[this.datatype].validate\n    , validated = validator(this.field, val, {});\n  return !validated.err;\n};\n\ncomparison.create = function () {\n  var args = Array.prototype.slice.call(arguments)\n    , type = args.shift()\n    , ctor = utils.string.capitalize(type) + 'Comparison'\n    , inst;\n\n    ctor = comparisonTypes[ctor];\n    inst = new ctor();\n    inst.type = type;\n    inst.initialize.apply(inst, args);\n    return inst;\n};\n\nComparisonBase = function () {\n  this.initialize = function (model, field, value, datatype, opts) {\n    this.parent = null;\n    this.descendants = [];\n    // FIXME: Should use Property objects\n    this.model = model;\n    this.field = field;\n    this.value = value;\n    this.datatype = datatype;\n    this.opts = opts || {};\n  };\n\n  // Most basic validation is to check that the value for the\n  // comparison is actually valid for this field\n  this.isValid = function () {\n    return _validateForDatatype.apply(this, [this.value]);\n  };\n};\n\ncomparisonTypes = {\n  EqualToComparison: function () {\n    this.jsComparatorString = '==';\n    this.sqlComparatorString = '=';\n  }\n\n, NotEqualToComparison: function () {\n    this.jsComparatorString = '!=';\n    this.sqlComparatorString = '!=';\n  }\n\n, GreaterThanComparison: function () {\n    this.jsComparatorString = '>';\n    this.sqlComparatorString = '>';\n  }\n\n, LessThanComparison: function () {\n    this.jsComparatorString = '<';\n    this.sqlComparatorString = '<';\n  }\n\n, GreaterThanOrEqualComparison: function () {\n    this.jsComparatorString = '>=';\n    this.sqlComparatorString = '>=';\n  }\n\n, LessThanOrEqualComparison: function () {\n    this.jsComparatorString = '<=';\n    this.sqlComparatorString = '<=';\n  }\n\n, InclusionComparison: function () {\n    this.sqlComparatorString = 'IN';\n\n    this.isValid = function () {\n      var self = this\n        , val = this.value;\n      if (!Array.isArray(val)) {\n        return false;\n      }\n      return val.every(function (item) {\n        return _validateForDatatype.apply(self, [item]);\n      });\n    };\n  }\n\n, LikeComparison: function () {\n    this.sqlComparatorString = 'LIKE';\n\n    this.isValid = function () {\n      if (!(this.datatype == 'string' || this.datatype == 'text')) {\n        return false;\n      }\n      return this.constructor.prototype.isValid.call(this);\n    };\n  }\n\n};\n\n(function () {\n  var ctor;\n  for (var t in comparisonTypes) {\n    ctor = comparisonTypes[t];\n    ctor.prototype = new ComparisonBase();\n    ctor.prototype.constructor = ctor;\n  }\n})();\n\n// Export the specific constructors as well as the `create` function\nutils.mixin(comparison, comparisonTypes);\n\nmodule.exports = comparison;\n\n\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/datatypes.js":"/*\n * Geddy JavaScript Web development framework\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nvar model = require('./index')\n  , utils = require('utilities')\n  , i18n = utils.i18n\n  , datatypes\n  , _isArray\n  , _serialize\n  , _quoteize\n  , _escape;\n\n_isArray = function (obj) {\n  // Defer to native if possible\n  if (typeof Array.isArray == 'function') {\n    return Array.isArray(obj);\n  }\n  return obj &&\n    typeof obj === 'object' &&\n    typeof obj.length === 'number' &&\n    typeof obj.splice === 'function' &&\n    !(obj.propertyIsEnumerable('length'));\n};\n\n_serialize = function (input, options) {\n  var val = String(input)\n    , opts = options || {};\n  if (opts.escape) {\n    val = _escape(val, opts.escape);\n  }\n  if (opts.useQuotes) {\n    val = _quoteize(val);\n  }\n  if (opts.lowercase) {\n    val = val.toLowerCase();\n  }\n  return val;\n};\n\n_quoteize = function (val) {\n  return [\"'\", \"'\"].join(val);\n}\n\n_escape = function (s, type) {\n  var ret;\n  switch (type) {\n    // Scrub input for basic SQL injection protection\n    case 'sql':\n      ret = s.replace(/'/g, \"''\");\n      break;\n    // Backslash-esc single quotes for use in M/R JS sourcecode str\n    case 'js':\n      ret = s.replace(/'/g, \"\\\\'\");\n      break;\n    default:\n      throw new Error(type + ' is not a valid type of escaping.');\n  }\n  return ret;\n};\n\n/*\n * Datatype verification -- may modify the value by casting\n */\ndatatypes = {\n\n  'string': {\n    validate: function (name, val, locale) {\n      return {\n        err: null\n      , val: String(val)\n      };\n    }\n  , serialize: function (input, options) {\n      return _serialize(input, options);\n    }\n  }\n\n, 'text': {\n    validate: function (name, val, locale) {\n      return {\n        err: null\n      , val: String(val)\n      };\n    }\n  , serialize: function (input, options) {\n      return _serialize(input, options);\n    }\n  }\n\n, 'number': {\n    validate: function (name, val, locale) {\n      if (isNaN(val)) {\n        return {\n          err: i18n.getText('model.validatesNumber', {name: name}, locale)\n        , val: null\n        };\n      }\n      return {\n        err: null\n      , val: Number(val)\n      };\n    }\n  , serialize: function (input, options) {\n      var opts = options || {};\n      return _serialize(input, {\n        escape: opts.escape\n      });\n    }\n  }\n\n, 'int': {\n    validate: function (name, val, locale) {\n      // Allow decimal values like 10.0 and 3.0\n      if (Math.round(val) != val) {\n        return {\n          err: i18n.getText('model.validatesInteger', {name: name}, locale)\n        , val: null\n        };\n      }\n      return {\n        err: null\n      , val: parseInt(val, 10)\n      };\n    }\n  , serialize: function (input, options) {\n      var opts = options || {};\n      return _serialize(input, {\n        escape: opts.escape\n      });\n    }\n  }\n\n, 'boolean': {\n    validate: function (name, val, locale) {\n      var validated;\n      switch (typeof val) {\n        case 'string':\n          switch (val) {\n            case 'true':\n            case 't':\n            case 'yes':\n            case '1':\n              validated = true;\n              break;\n            case 'false':\n            case 'f':\n            case 'no':\n            case '0':\n              validated = false;\n              break;\n          }\n          break;\n        case 'number':\n          if (val == 1) {\n            validated = true;\n          }\n          else if (val == 0) {\n            validated = false;\n          }\n          break;\n        case 'boolean':\n          validated = val;\n          break;\n        default:\n          // Nothing\n      }\n\n      if (typeof validated != 'boolean') {\n        return {\n          err: i18n.getText('model.validatesBoolean', {name: name}, locale)\n        , val: null\n        };\n      }\n      return {\n        err: null\n        , val: validated\n      };\n    }\n  , serialize: function (input, options) {\n      var opts = options || {};\n      return _serialize(input, {\n        escape: opts.escape\n      });\n    }\n  }\n\n, 'object': {\n    validate: function (name, val, locale) {\n      // Allow saving of arrays as the datatype array only saves arrays\n      // of numbers or strings correctly, but not arrays of objects\n      // We're just not bothing with a separate Array datatype anymore\n\n      // maybe a JSON string?\n      if (typeof val === 'string') {\n        try {\n          var obj = JSON.parse(val);\n          return {\n            err: null,\n            val: obj\n          }\n        }\n        catch(err) {\n          return {\n            err: i18n.getText('model.validatesObject', {name: name}, locale),\n            val: null\n          }\n        }\n      }\n      else if (typeof val != 'object') {\n        return {\n          err: i18n.getText('model.validatesObject', {name: name}, locale)\n        , val: null\n        };\n      }\n      return {\n        err: null\n      , val: val\n      };\n    }\n  , serialize: function (input, options) {\n      var val\n        , opts = options || {};\n\n      // Arrays will be converted to JSON\n      if (_isArray(input)) {\n          val = JSON.stringify(input);\n      }\n      // Otherwise just try to serialize via toString\n      else if (typeof input.toString == 'function') {\n        val = input.toString();\n        // If this happens the object had no usefull toString()\n        // method and we should make JSON out of it\n        if (val == \"[object Object]\") {\n          val = JSON.stringify(input);\n        }\n      }\n      else {\n        val = JSON.stringify(input);\n      }\n      // FIXME: Does escaping a JSONized object make sense?\n      return _serialize(val, opts);\n    }\n  }\n\n, 'date': {\n    validate: function (name, val, locale) {\n      var dt = utils.date.parse(val);\n      if (dt) {\n        return {\n          err: null\n        , val: dt\n        };\n      }\n      else {\n        return {\n          err: i18n.getText('model.validatesDate', {name: name}, locale)\n        , val: null\n        };\n      }\n    }\n  , serialize: function (input, options) {\n      var val\n        , opts = options || {};\n      if (model.config.useUTC) {\n        val = utils.date.toUTC(input);\n      }\n      else {\n        val = input;\n      }\n      val = utils.date.strftime(val, '%F');\n      return _serialize(val, opts);\n    }\n  }\n\n, 'datetime': {\n    validate: function (name, val, locale) {\n      var dt = utils.date.parse(val);\n      if (dt) {\n        return {\n          err: null\n        , val: dt\n        };\n      }\n      else {\n        return {\n          err: i18n.getText('model.validatesDatetime', {name: name}, locale)\n        , val: null\n        };\n      }\n    }\n  , serialize: function (input, options) {\n      var val\n        , opts = options || {};\n      if (model.config.useUTC) {\n        val = utils.date.toUTC(input);\n      }\n      else {\n        val = input;\n      }\n      val = utils.date.toISO8601(val, {utc: true});\n      return _serialize(val, options);\n    }\n  }\n\n  // This is a hack -- we're saving times as Dates of 12/31/1969, and the\n  // desired time\n, 'time': {\n    validate: function (name, val, locale) {\n      var dt = utils.date.parse(val);\n      if (dt) {\n        return {\n          err: null\n        , val: dt\n        };\n      }\n      else {\n        return {\n          err: i18n.getText('model.validatesTime', {name: name}, locale)\n        , val: null\n        };\n      }\n    }\n  , serialize: function (input, options) {\n      var val\n        , opts = options || {};\n      val = utils.date.strftime(val, '%T');\n      return _serialize(val, opts);\n    }\n  }\n\n};\n\nmodule.exports = datatypes;\n\n// Lazy-load; model loads this file first\nmodel = require('./index');\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/association/index.js":"var association\n  , model = require('../index')\n  , utils = require('utilities');\n\nassociation = new (function () {\n\n  this.getThroughAssnKey = function (assn, assnType, modelType, opts) {\n    var through = assn.through\n      , assns\n      , reg = model.descriptionRegistry\n      , keyAssn\n      , keyName\n      , side = opts.side;\n\n    if (side == 'other') {\n      if (!assn.inverse) {\n        // Look through other associations, find the inverse, and cache\n        // for later lookup\n        for (var p in reg) {\n          assns = reg[p].associations[assnType];\n          for (var q in assns) {\n            if (q != assn.name && assns[q].through == through) {\n              assn.inverse = assns[q];\n            }\n          }\n        }\n      }\n      if (!assn.inverse) {\n        throw new Error('No inverse found for this through-association.');\n      }\n      keyAssn = assn.inverse;\n    }\n    else {\n      keyAssn = assn;\n    }\n\n    if (keyAssn.name != keyAssn.model) {\n      keyName = keyAssn.name + keyAssn.model;\n    }\n    else {\n      keyName = keyAssn.name;\n    }\n    keyName = utils.string.decapitalize(keyName + 'Id');\n\n    return keyName;\n  };\n\n  this._getAssociation = function () {\n    var args = Array.prototype.slice.call(arguments)\n      , assnName = args.shift()\n      , assnType = args.shift()\n      , callback = args.pop()\n      , query\n      , throughQuery\n      , opts\n      , otherKeyName\n      , selfKeyName\n      , keyName\n      , queryName\n      , reg = model.descriptionRegistry\n      , assn = reg[this.type].associations[assnType]\n      , modelName\n      , through\n      , throughModelName\n      , throughAssn;\n\n    // Bail out if the association doesn't exist\n    if (!assn) {\n      throw new Error('Model ' + this.type + ' does not have ' + assnType +\n          ' association.');\n    }\n\n    modelName = assn[assnName].model;\n    through = assn[assnName].through;\n\n    // Normalize inflection\n    modelName = utils.inflection.singularize(modelName);\n    assnName = utils.inflection.singularize(assnName);\n\n    // Has query object\n    if (assnType == 'hasMany') {\n      if (through) {\n        query = {};\n        throughQuery = args.shift() || {};\n      }\n      else {\n        query = args.shift() || {};\n      }\n    }\n    // No query object, create one\n    else {\n      query = {};\n    }\n    // Lastly grab opts if any\n    opts = args.shift() || {};\n\n    // I belong to the other model; look for the item\n    // whose id matches my foreign key for that model\n    if (assnType == 'belongsTo') {\n      otherKeyName = modelName;\n      if (modelName != assnName) {\n        otherKeyName = assnName + otherKeyName;\n      }\n      otherKeyName = utils.string.decapitalize(otherKeyName + 'Id');\n      query.id = this[otherKeyName];\n    }\n    // The other model belongs to me; look for any\n    // items whose foreign keys match my id\n    // (hasOne is just a special case of hasMany)\n    else {\n      if (through) {\n        selfKeyName = association.getThroughAssnKey(assn[assnName], assnType,\n            this.type, {side: 'other'});\n      }\n      else {\n        selfKeyName = this.type;\n        if (modelName != assnName) {\n          selfKeyName = assnName + selfKeyName;\n        }\n        selfKeyName = utils.string.decapitalize(selfKeyName + 'Id');\n      }\n\n      query[selfKeyName] = this.id;\n    }\n\n    queryName = assnType == 'hasMany' ? 'all' : 'first';\n\n    // -----------\n    // FIXME: This is pretty terrible -- should really do these\n    // async queries in some sort of composable Promisey API\n    // TODO: Optimize SQL adapters by using eager-fetch w. join\n    // -----------\n    // Through's -- get the join-model instances, and re-fetch\n    // actual assns\n    if (through) {\n      through = utils.string.getInflection(through, 'constructor', 'singular');\n      model[through][queryName](query, opts, function (err, data) {\n        var query = throughQuery\n          , idColName\n          , idParam;\n\n        if (err) {\n          return callback(err, null);\n        }\n\n        idColName = association.getThroughAssnKey(assn[assnName], assnType,\n            modelName, {side: 'this'});\n\n        if (assnType == 'hasMany') {\n          idParam = [];\n          data.forEach(function (item) {\n            idParam.push(item[idColName]);\n          });\n        }\n        else {\n          idParam = item[idColName];\n        }\n        // No join-instances, no associated items\n        if (!idParam.length) {\n          callback(null, []);\n        }\n        else {\n          query.id = idParam;\n          model[modelName][queryName](query, opts, callback);\n        }\n      });\n    }\n    // Normal assns, just do the damn query\n    else {\n      model[modelName][queryName](query, opts, callback);\n    }\n  };\n\n  this._createAssociation = function () {\n    var args = Array.prototype.slice.call(arguments)\n      , assnName = args.shift()\n      , assnType = args.shift()\n      , data = args.shift()\n      , otherKeyName\n      , selfKeyName\n      , reg = model.descriptionRegistry\n      , assn = reg[this.type].associations[assnType]\n      , modelName\n      , through\n      , throughModelName\n      , throughAssn\n      , joinInstance\n      , unsaved\n      , params;\n\n    // Bail out if the association doesn't exist\n    if (!assn) {\n      throw new Error('Model ' + this.type + ' does not have ' + assnType +\n          ' association.');\n    }\n\n    modelName = assn[assnName].model\n    through = assn[assnName].through;\n\n    // Normalize inflection\n    modelName = utils.inflection.singularize(modelName);\n    assnName = utils.inflection.singularize(assnName);\n\n    otherKeyName = modelName;\n    selfKeyName = this.type;\n\n    // belongsTo\n    if (assnType == 'belongsTo') {\n      if (!(data._saved && data.id)) {\n        throw new Error('Item cannot have a belongTo association ' +\n            'if the item it belongs to is not yet saved.');\n      }\n      // Prefix named assns\n      if (modelName != assnName) {\n        otherKeyName = assnName + otherKeyName;\n      }\n      otherKeyName = utils.string.decapitalize(otherKeyName + 'Id');\n\n      this[otherKeyName] = data.id;\n      unsaved = data._unsavedAssociations || [];\n      unsaved.push({operation: 'save', item: this});\n      data._unsavedAssociations = unsaved;\n    }\n    // hasOne, hasMany (through)\n    else {\n      if (!(this._saved && this.id)) {\n        throw new Error('Item cannot have a hasOne/hasMany association ' +\n            'if it is not yet saved.');\n      }\n\n      // ---------------\n      // FIXME: This chained saving happens automagically, so\n      // validation errors in the instances just throw, with\n      // no visible .errors property\n      // ---------------\n      // Through assn\n      if (through) {\n        // Prefix named assns\n        if (modelName != assnName) {\n          otherKeyName = assnName + otherKeyName;\n        }\n        otherKeyName = association.getThroughAssnKey(assn[assnName], assnType,\n            this.type, {side: 'this'});\n        selfKeyName = association.getThroughAssnKey(assn[assnName], assnType,\n            this.type, {side: 'other'});\n\n        through = utils.string.getInflection(through, 'constructor', 'singular');\n        // Create join-instance\n        params = {};\n        params[selfKeyName] = this.id;\n        joinInstance = model[through].create(params);\n\n        unsaved = this._unsavedAssociations || [];\n        if (!data._saved) {\n          // Mark actual assn for chained save\n          unsaved.push({operation: 'save', item: data});\n          // When this item gets saved, update the join-instance\n          // with the correct assn foreign key\n          data.on('save', function () {\n            joinInstance[otherKeyName] = data.id;\n          });\n        }\n        else {\n          joinInstance[otherKeyName] = data.id;\n        }\n        // Mark join-instance for chained save\n        unsaved.push({operation: 'save', item: joinInstance});\n        this._unsavedAssociations = unsaved;\n      }\n      else {\n        // Prefix named assns\n        if (modelName != assnName) {\n          selfKeyName = assnName + selfKeyName;\n        }\n        selfKeyName = utils.string.decapitalize(selfKeyName + 'Id');\n\n        data[selfKeyName] = this.id;\n        unsaved = this._unsavedAssociations || [];\n        unsaved.push({operation: 'save', item: data});\n        this._unsavedAssociations = unsaved;\n      }\n    }\n  };\n\n  this._removeAssociation = function () {\n    var args = Array.prototype.slice.call(arguments)\n      , assnName = args.shift()\n      , assnType = args.shift()\n      , data = args.shift()\n      , otherKeyName\n      , selfKeyName\n      , reg = model.descriptionRegistry\n      , assn = reg[this.type].associations[assnType]\n      , modelName\n      , through\n      , throughModelName\n      , throughAssn\n      , removeQuery\n      , unsaved\n      , params;\n\n    // Bail out if the association doesn't exist\n    if (!assn) {\n      throw new Error('Model ' + this.type + ' does not have ' + assnType +\n          ' association.');\n    }\n\n    modelName = assn[assnName].model\n    through = assn[assnName].through;\n\n    // Normalize inflection\n    modelName = utils.inflection.singularize(modelName);\n    assnName = utils.inflection.singularize(assnName);\n\n    otherKeyName = modelName;\n    selfKeyName = this.type;\n\n    // belongsTo -- remove the foreign-key value on this obj\n    if (assnType == 'belongsTo') {\n      if (modelName != assnName) {\n        otherKeyName = assnName + otherKeyName;\n      }\n      otherKeyName = utils.string.decapitalize(otherKeyName + 'Id');\n\n      this[otherKeyName] = null; // Remove value\n      unsaved = data._unsavedAssociations || [];\n      unsaved.push({operation: 'save', item: this});\n      data._unsavedAssociations = unsaved;\n    }\n    // hasOne, hasMany (through) -- remove the foreign-key value\n    // on the other obj, or remove the join-model instance for through-assn\n    else {\n      // ---------------\n      // FIXME: This chained saving happens automagically, so\n      // validation errors in the instances just throw, with\n      // no visible .errors property\n      // ---------------\n      // Through assn\n      if (through) {\n        // Prefix named assns\n        if (modelName != assnName) {\n          otherKeyName = assnName + otherKeyName;\n        }\n        otherKeyName = association.getThroughAssnKey(assn[assnName], assnType,\n            this.type, {side: 'this'});\n        selfKeyName = association.getThroughAssnKey(assn[assnName], assnType,\n            this.type, {side: 'other'});\n\n        through = utils.string.getInflection(through, 'constructor', 'singular');\n\n        // Create join-instance\n        removeQuery = {};\n        removeQuery[selfKeyName] = this.id;\n        removeQuery[otherKeyName] = data.id;\n\n        unsaved = this._unsavedAssociations || [];\n        // Mark join-instance for removal\n        unsaved.push({operation: 'remove', query: removeQuery, through: through});\n        this._unsavedAssociations = unsaved;\n      }\n      else {\n        // Prefix named assns\n        if (modelName != assnName) {\n          selfKeyName = assnName + selfKeyName;\n        }\n        selfKeyName = utils.string.decapitalize(selfKeyName + 'Id');\n\n        data[selfKeyName] = null;\n        unsaved = this._unsavedAssociations || [];\n        unsaved.push({operation: 'save', item: data});\n        this._unsavedAssociations = unsaved;\n      }\n    }\n  };\n\n  this._commitAssociationChanges = function (callback) {\n    var self = this\n      , assn\n      , unsaved = this._unsavedAssociations || []\n      , doIt = function () {\n          if ((assn = unsaved.shift())) {\n            if (assn.operation == 'save') {\n              assn.item.save(function (err, data) {\n                if (err) {\n                  callback(err);\n                }\n                else {\n                  doIt();\n                }\n              });\n            }\n            // Through-associations, removing join-model inst\n            else if (assn.operation == 'remove') {\n              model[assn.through].remove(assn.query, function (err, data) {\n                if (err) {\n                  callback(err);\n                }\n                else {\n                  doIt();\n                }\n              });\n            }\n            else {\n              callback(new Error('Association items can only be saved or removed.'));\n            }\n          }\n          else {\n            callback();\n          }\n        };\n\n    doIt();\n  };\n\n})();\n\nmodule.exports = association;\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/adapters/base_adapter.js":"var BaseAdapter\n  , configPropertyAliases\n  , EventEmitter = require('events').EventEmitter\n  , model = require('../index')\n  , adapter = require('./index')\n  , utils = require('utilities');\n\nconfigPropertyAliases = [\n  ['user', 'username', 'userName']\n, ['pass', 'password']\n, ['database', 'dbname', 'db', 'dbName']\n, ['host', 'hostname', 'hostName']\n];\n\nBaseAdapter = function () {\n};\n\nBaseAdapter.prototype = new EventEmitter();\nutils.mixin(BaseAdapter.prototype, new (function () {\n\n  this.loadConfig = function (baseConfig, options) {\n    var base = utils.mixin({}, baseConfig)\n      , opts = utils.mixin({}, options || {})\n      , found\n      , aliasKeys\n      , aliasKey;\n    // If there's a property name on the passed in opts that is\n    // an alias for a property on the config, set the correct\n    // property name and delete the alias\n    for (var p in base) {\n      // Is this possibly an aliased property?\n      found = configPropertyAliases.some(function (aliases) {\n        aliasKeys = aliases;\n        return aliases.indexOf(p) > -1;\n      });\n      if (found) {\n        // Does the opts obj have an aliased keys?\n        found = aliasKeys.some(function (alias) {\n          aliasKey = alias;\n          // Possible key isn't the same as the real key\n          // Key has a defined value on the opts obj\n          return alias != p && typeof opts[alias] != 'undefined';\n        });\n        if (found) {\n          opts[p] = opts[aliasKey];\n          delete opts[aliasKey]\n        }\n      }\n    }\n    return utils.mixin(base, opts);\n  };\n\n  this.connect = function (callback) {\n    var self = this\n      , cb = callback || function () {};\n    setTimeout(function () {\n      self.emit('connect');\n      cb();\n    }, 0);\n  };\n\n  this.disconnect = function (callback) {\n    var self = this\n      , cb = callback || function () {};\n    setTimeout(function () {\n      self.emit('disconnect');\n      cb();\n    }, 0);\n  };\n\n  this.load = function (query, callback) {\n    callback(null, []);\n  };\n\n  this.update = function (data, query, callback) {\n    if (data instanceof model.ModelBase) {\n      callback(null, data);\n    }\n    else {\n      callback(null, true);\n    }\n  };\n\n  this.remove = function (query, callback) {\n    callback(null, true);\n  };\n\n  this.insert = function (data, opts, callback) {\n    data.id = data.id || utils.string.uuid()\n    data._saved = true;\n    callback(null, data);\n  };\n\n  this.count = function (query, callback) {\n    callback(null, 0);\n  };\n\n  this.createTable = function (names, callback) {\n    callback(null, null);\n  };\n\n  this.dropTable = function (names, callback) {\n    callback(null, null);\n  };\n\n})());\n\nmodule.exports.BaseAdapter = BaseAdapter;\n","/home/travis/build/npmtest/node-npmtest-model/node_modules/model/lib/query/sql_adapter.js":"\nvar SQLAdapter = function () {\n\n  var quoteName = function (name) {\n        return '\"' + name.replace(/\"/g, '\"\"') + '\"';\n      }\n\n    , columnsStatement = function (properties, qualify) {\n        return properties.map(function (property) {\n          return propertyToColumnName(property, qualify);\n        }).join(', ');\n      }\n\n    , propertyToColumnName = function (property, qualify) {\n        columnName = '';\n        if (qualify === true) {\n          // TODO\n        }\n        else if (typeof qualify == 'string') {\n          columnName += quoteName(qualify);\n        }\n        columnName += quoteName(property);\n        return columnName;\n      };\n\n  this.selectStatement = function (query) {\n    var qualify = !!query.links.length;\n      , fields = query.fields\n      , orderBy = query.order\n      , conditionsStatement;\n\n    conditionsStatement = this.conditionsStatement(query.conditions);\n  };\n\n  this.conditionsStatement = function (conditions) {\n    var statement = '';\n\n    switch (true) {\n    }\n  };\n};\n"}